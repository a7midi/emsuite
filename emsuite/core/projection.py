# emsuite/core/projection.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Tuple, Hashable, Iterable, Optional
import hashlib

from .graph import DiGraph, Vertex
from .grammar import Grammar, LocalRule, Symbol, InputTuple


@dataclass(frozen=True)
class Diamond:
    """
    Diamond i -> v, i -> w, v -> x, w -> x in the *original* graph G.

    We do NOT require condensation here: the coherence constraints are
    local to the original graph's adjacency, so we detect diamonds directly.
    """
    i: Vertex
    v: Vertex
    w: Vertex
    x: Vertex


def find_diamonds(graph: DiGraph, sample_limit: Optional[int] = None) -> List[Diamond]:
    """
    Find all directed diamonds (i, v, w, x) in the given graph:

        i -> v, i -> w, v -> x, w -> x, with v != w.

    For large graphs you can pass sample_limit to stop early.
    """
    diamonds: List[Diamond] = []
    for i in graph.vertices():
        succ_i = list(graph.successors(i))
        if len(succ_i) < 2:
            continue
        # Pick unordered pairs {v, w} of successors of i
        for idx_v in range(len(succ_i)):
            v = succ_i[idx_v]
            for idx_w in range(idx_v + 1, len(succ_i)):
                w = succ_i[idx_w]
                # Find common successors x of v and w
                succ_v = set(graph.successors(v))
                succ_w = set(graph.successors(w))
                common = succ_v & succ_w
                for x in common:
                    diamonds.append(Diamond(i=i, v=v, w=w, x=x))
                    if sample_limit is not None and len(diamonds) >= sample_limit:
                        return diamonds
    return diamonds


def _canonical_output(
    v: Vertex,
    preds: Tuple[Vertex, ...],
    canonical_inp: InputTuple,
    alphabet: Tuple[Symbol, ...],
) -> Symbol:
    """
    Deterministic mapping (v, preds, canonical_inp) -> output symbol in alphabet.

    This is deliberately independent of the *initial* random rule table:
      - depends only on (graph structure, alphabets),
      - stable across runs (pure hash),
      - ensures many random grammars on the same graph flow to the SAME
        fixed grammar under projection.
    """
    if not alphabet:
        raise ValueError(f"Empty alphabet at vertex {v!r}")

    h = hashlib.sha256()
    h.update(repr(v).encode("utf-8"))
    h.update(repr(preds).encode("utf-8"))
    h.update(repr(canonical_inp).encode("utf-8"))
    digest = int.from_bytes(h.digest(), byteorder="big", signed=False)
    idx = digest % len(alphabet)
    return alphabet[idx]


def _build_symmetry_pairs(
    graph: DiGraph,
    grammar: Grammar,
    diamonds: Iterable[Diamond],
) -> Dict[Vertex, List[Tuple[int, int]]]:
    """
    For each vertex x, build a list of index pairs (i, j) in its predecessor
    list that must be symmetric because of some diamond i -> v, i -> w, v -> x, w -> x.

    More precisely: if (i, v, w, x) is a diamond and both v, w appear in the
    predecessor list of x, then the coordinates corresponding to v and w
    must be symmetric in λ_x.

    We collect these as pairs (idx_v, idx_w). Multiple diamonds may add
    multiple pairs; we later close them up via union–find.
    """
    sym_pairs: Dict[Vertex, List[Tuple[int, int]]] = {}

    for d in diamonds:
        x = d.x
        rule_x: Optional[LocalRule] = grammar.rules.get(x)
        if rule_x is None:
            continue
        preds_x = rule_x.preds
        try:
            idx_v = preds_x.index(d.v)
            idx_w = preds_x.index(d.w)
        except ValueError:
            # This can happen if grammar predecessors are a strict subset
            # or have been ordered differently; in that case we simply
            # skip this particular diamond for x.
            continue

        i, j = sorted((idx_v, idx_w))
        if x not in sym_pairs:
            sym_pairs[x] = []
        if (i, j) not in sym_pairs[x]:
            sym_pairs[x].append((i, j))

    return sym_pairs


def _components_from_pairs(num_slots: int, pairs: List[Tuple[int, int]]) -> List[List[int]]:
    """
    Given a number of input slots and a list of symmetric index pairs (i, j),
    build connected components under the equivalence relation generated by
    those pairs.

    Each component corresponds to a set of coordinates that may be permuted
    without changing the output under diamond–coherence.
    """
    if num_slots <= 0:
        return []

    parent = list(range(num_slots))

    def find(x: int) -> int:
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a: int, b: int) -> None:
        ra, rb = find(a), find(b)
        if ra != rb:
            parent[rb] = ra

    for i, j in pairs:
        if 0 <= i < num_slots and 0 <= j < num_slots:
            union(i, j)

    comps_dict: Dict[int, List[int]] = {}
    for idx in range(num_slots):
        root = find(idx)
        comps_dict.setdefault(root, []).append(idx)

    return list(comps_dict.values())


def _canonicalise_input(inp: InputTuple, components: List[List[int]]) -> InputTuple:
    """
    Given an input tuple and a list of components (each a list of indices),
    return the canonical representative of the orbit under all permutations
    within each component.

    Implementation:
      - For each component C:
          * collect the values inp[i] for i in C,
          * sort indices C and sorted values,
          * assign sorted values back to the sorted indices.

    This is equivalent to sorting the values within each symmetry block,
    and ensures all tuples reachable by swapping symmetric coordinates
    collapse to the same canonical tuple.
    """
    if not components:
        return inp

    t = list(inp)
    for comp in components:
        if len(comp) <= 1:
            continue
        idxs = sorted(comp)
        vals = [t[i] for i in idxs]
        # Symbols are 0/1 (binary alphabet) in the current suite,
        # so direct sorting is deterministic and well-defined.
        vals_sorted = sorted(vals)
        for i, val in zip(idxs, vals_sorted):
            t[i] = val
    return tuple(t)


def project_to_consistent(grammar: Grammar, max_iter: int = 10) -> Grammar:
    """
    Diamond-coherent projection on rule space.

    For a given finite graph and alphabet assignment, this operator:

      1. Detects all diamonds (i, v, w, x) in the underlying graph:
            i -> v, i -> w, v -> x, w -> x.

      2. For each target vertex x, finds coordinate pairs in Pred(x)
         that correspond to (v, w) in some diamond, and builds the
         equivalence relation generated by those swaps.

      3. For each local rule λ_x, enforces *full symmetry* of the table
         under those swaps by:
            - mapping each input tuple to its canonical representative
              under the swap-generated group,
            - assigning outputs via a deterministic hash of
              (x, Pred(x), canonical_input, alphabet).

    Consequences:

      - Diamond coherence:
          For any diamond and any choice of inputs, swapping the inputs
          along the two branches yields the SAME output at x, because
          the two input tuples have the same canonical representative.

      - Idempotence:
          project_to_consistent(P(Λ)) = P(Λ). Once tables are written
          in canonical form, applying the map again does nothing.

      - Attractor property:
          For fixed (graph, alphabets) this projection does *not*
          depend on the initial random tables; all grammars collapse
          to the same canonical one (up to trivial index/label symmetries).

    NOTE:
      This is now a genuine diamond-driven projection (it actually uses
      diamonds and the induced index-gauge symmetries), not just a local
      heuristic symmetry fixer.
    """
    graph = grammar.graph

    diamonds = find_diamonds(graph)
    sym_pairs_by_vertex = _build_symmetry_pairs(graph, grammar, diamonds)

    new_rules: Dict[Vertex, LocalRule] = {}

    for v, old_rule in grammar.rules.items():
        preds = old_rule.preds
        alphabet = grammar.alphabets[v]
        swap_pairs = sym_pairs_by_vertex.get(v, [])

        components = _components_from_pairs(len(preds), swap_pairs)
        new_table: Dict[InputTuple, Symbol] = {}

        # We preserve the domain of the original table (keys),
        # but redefine outputs canonically.
        for inp in old_rule.table.keys():
            canonical_inp = _canonicalise_input(inp, components)
            out_symbol = _canonical_output(v, preds, canonical_inp, alphabet)
            new_table[inp] = out_symbol

        new_rules[v] = LocalRule(preds=preds, table=new_table)

    return Grammar(graph=graph, rules=new_rules, alphabets=grammar.alphabets)
